"""
Player class implementing the T-Rex character

Demonstrates Inheritance and Polymorphism by extending GameObject
and implementing State pattern for player behaviors.
"""

from enum import Enum
from typing import List
from game.entities.game_object import GameObject

class PlayerState(Enum):
    """Player state enumeration for State pattern"""
    RUNNING = "running"
    JUMPING = "jumping"
    DUCKING = "ducking"

class Player(GameObject):
    """
    Enhanced Player class representing the T-Rex dinosaur
    
    Demonstrates:
    - Inheritance: Extends GameObject
    - Polymorphism: Overrides abstract methods with player-specific behavior
    - Encapsulation: Private state management
    - State Pattern: Different behaviors based on current state
    - Enhanced Animation: Improved visual feedback
    """
    
    # Enhanced class constants
    JUMP_HEIGHT = 6
    GRAVITY = 1
    JUMP_VELOCITY = -6
    
    # Enhanced animation sprites with more variety
    RUN_SPRITES = ['ðŸ¦•', 'ðŸ¦–', 'ðŸ¦´']  # Running animation with bone kick
    JUMP_SPRITES = ['ðŸ¦…', 'âœˆï¸']      # Jumping animation
    DUCK_SPRITES = ['ðŸŠ', 'ðŸ']      # Ducking animation  
    CELEBRATION_SPRITES = ['ðŸŽ‰', 'ðŸ†', 'â­']  # Milestone celebrations
    
    def __init__(self, x: int, ground_y: int):
        """
        Initialize enhanced player
        
        Args:
            x: Starting X position
            ground_y: Ground level Y coordinate
        """
        super().__init__(x, ground_y, self.RUN_SPRITES[0])
        
        # Enhanced state management
        self._state = PlayerState.RUNNING
        self._ground_y = ground_y
        self._velocity_y = 0
        self._jump_count = 0  # For double jump feature
        self._max_jumps = 1   # Can be upgraded
        
        # Enhanced animation system
        self._animation_time = 0.0
        self._animation_speed = 0.3
        self._sprite_index = 0
        self._celebration_timer = 0
        
        # Player stats for enhanced gameplay
        self._jumps_performed = 0
        self._ducks_performed = 0
        self._distance_traveled = 0.0
        self._ground_y = ground_y
        self._velocity_y = 0
        self._animation_frame = 0
        self._animation_timer = 0
        self._animation_speed = 10  # Frames between animation changes
        
        # Adjust size based on state
        self._width = 2
        self._height = 2
    
    @property
    def state(self) -> PlayerState:
        """Get current player state"""
        return self._state
    
    @property
    def ground_y(self) -> int:
        """Get ground level"""
        return self._ground_y
    
    @property
    def is_on_ground(self) -> bool:
        """Check if player is on ground"""
        return self._y >= self._ground_y
    
    def jump(self) -> bool:
        """
        Make player jump (only if on ground and running)
        
        Returns:
            True if jump was successful
        """
        if self._state == PlayerState.RUNNING and self.is_on_ground:
            self._state = PlayerState.JUMPING
            self._velocity_y = self.JUMP_VELOCITY
            self._sprite = self.JUMP_SPRITE
            return True
        return False
    
    def duck(self) -> bool:
        """
        Make player duck
        
        Returns:
            True if duck was successful
        """
        if self._state in [PlayerState.RUNNING, PlayerState.JUMPING]:
            self._state = PlayerState.DUCKING
            self._sprite = self.DUCK_SPRITE
            self._height = 1  # Smaller hitbox when ducking
            if self.is_on_ground:
                self._y = self._ground_y  # Adjust position
            return True
        return False
    
    def stop_ducking(self) -> bool:
        """
        Stop ducking and return to running
        
        Returns:
            True if successful
        """
        if self._state == PlayerState.DUCKING and self.is_on_ground:
            self._state = PlayerState.RUNNING
            self._height = 2  # Restore normal height
            self._y = self._ground_y - 1  # Adjust position
            return True
        return False
    
    def update(self) -> None:
        """
        Enhanced update with better animations and physics
        
        This method demonstrates polymorphism by providing player-specific
        implementation with enhanced visual feedback.
        """
        self._update_physics()
        self._update_enhanced_animation()
        self._update_sprite()
        self._update_stats()
    
    def _update_physics(self) -> None:
        """Enhanced physics with better jump mechanics"""
        if self._state == PlayerState.JUMPING:
            # Apply gravity
            self._velocity_y += self.GRAVITY
            self._y += self._velocity_y
            
            # Check for landing
            if self._y >= self._ground_y:
                self._y = self._ground_y
                self._velocity_y = 0
                self._state = PlayerState.RUNNING
                self._jump_count = 0  # Reset jump count on landing
    
    def _update_enhanced_animation(self) -> None:
        """Enhanced animation system with more fluid transitions"""
        self._animation_time += self._animation_speed
        
        # Handle celebration animation
        if self._celebration_timer > 0:
            self._celebration_timer -= 1
            celebration_index = int(self._animation_time * 3) % len(self.CELEBRATION_SPRITES)
            self._sprite = self.CELEBRATION_SPRITES[celebration_index]
            return
        
        # State-based animation
        if self._state == PlayerState.RUNNING:
            self._sprite_index = int(self._animation_time * 2) % len(self.RUN_SPRITES)
            self._sprite = self.RUN_SPRITES[self._sprite_index]
        elif self._state == PlayerState.JUMPING:
            # Animate jump based on velocity
            if self._velocity_y < 0:  # Going up
                self._sprite = self.JUMP_SPRITES[0]
            else:  # Coming down
                self._sprite = self.JUMP_SPRITES[1] if len(self.JUMP_SPRITES) > 1 else self.JUMP_SPRITES[0]
        elif self._state == PlayerState.DUCKING:
            self._sprite_index = int(self._animation_time * 4) % len(self.DUCK_SPRITES)
            self._sprite = self.DUCK_SPRITES[self._sprite_index]
    
    def _update_stats(self) -> None:
        """Update player statistics"""
        if self._state == PlayerState.RUNNING:
            self._distance_traveled += 0.1
    
    def jump(self) -> bool:
        """
        Enhanced jump with potential for double jump
        
        Returns:
            True if jump was successful
        """
        if (self._state == PlayerState.RUNNING and self.is_on_ground) or \
           (self._state == PlayerState.JUMPING and self._jump_count < self._max_jumps):
            self._state = PlayerState.JUMPING
            self._velocity_y = self.JUMP_VELOCITY
            self._jump_count += 1
            self._jumps_performed += 1
            return True
        return False
    
    def duck(self) -> bool:
        """
        Enhanced ducking with animation
        
        Returns:
            True if duck was successful
        """
        if self._state in [PlayerState.RUNNING, PlayerState.JUMPING]:
            self._state = PlayerState.DUCKING
            self._height = 1  # Smaller hitbox when ducking
            self._ducks_performed += 1
            if self.is_on_ground:
                self._y = self._ground_y  # Adjust position
            return True
        return False
    
    def trigger_celebration(self, duration: int = 30) -> None:
        """Trigger celebration animation"""
        self._celebration_timer = duration
    
    def get_stats(self) -> dict:
        """Get player statistics"""
        return {
            'jumps': self._jumps_performed,
            'ducks': self._ducks_performed,
            'distance': self._distance_traveled
        }
            # Apply gravity
            self._y += self._velocity_y
            self._velocity_y += self.GRAVITY
            
            # Check if landed
            if self._y >= self._ground_y:
                self._y = self._ground_y
                self._velocity_y = 0
                self._state = PlayerState.RUNNING
        
        elif self._state == PlayerState.RUNNING:
            # Ensure player stays on ground
            self._y = self._ground_y
    
    def _update_animation(self) -> None:
        """Update animation frame (Encapsulation - private method)"""
        if self._state == PlayerState.RUNNING:
            self._animation_timer += 1
            if self._animation_timer >= self._animation_speed:
                self._animation_frame = (self._animation_frame + 1) % len(self.RUN_SPRITES)
                self._animation_timer = 0
    
    def _update_sprite(self) -> None:
        """Update sprite based on current state (Encapsulation - private method)"""
        if self._state == PlayerState.RUNNING:
            self._sprite = self.RUN_SPRITES[self._animation_frame]
        elif self._state == PlayerState.JUMPING:
            self._sprite = self.JUMP_SPRITE
        elif self._state == PlayerState.DUCKING:
            self._sprite = self.DUCK_SPRITE
    
    def render(self) -> str:
        """
        Render player as string (Polymorphism)
        
        Returns:
            String representation of the player
        """
        if not self.active:
            return " " * self.width
        
        return self.sprite
    
    def get_collision_box(self) -> tuple:
        """
        Get collision box adjusted for current state
        
        Returns:
            Tuple of (x, y, width, height) for collision detection
        """
        if self._state == PlayerState.DUCKING:
            return (self.x, self.y, self.width, 1)
        else:
            return (self.x, self.y, self.width, self.height)
    
    def reset(self) -> None:
        """Reset player to initial state"""
        self._state = PlayerState.RUNNING
        self._y = self._ground_y
        self._velocity_y = 0
        self._animation_frame = 0
        self._animation_timer = 0
        self._height = 2
        self._sprite = self.RUN_SPRITES[0]
        self.set_active(True)
